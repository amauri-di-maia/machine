name: Brickovery - M3 Solve Seeds

on:
  workflow_dispatch:
    inputs:
      time_budget_minutes:
        description: "Solver time budget (minutes)"
        required: false
        default: "20"
      checkpoint_every_seconds:
        description: "Checkpoint interval (seconds)"
        required: false
        default: "120"
      penalty_store:
        description: "Penalty per store (EUR)"
        required: false
        default: "2.50"
      mode:
        description: "Solver mode (use: normal). Note: 'both' is NOT supported."
        required: false
        default: "normal"
      shipping_method:
        description: "Report focus: both | normal | registered (does not change solve; filters summary only)"
        required: false
        default: "both"

concurrency:
  group: brickovery-m3
  cancel-in-progress: false

jobs:
  solve:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install pydantic PyYAML beautifulsoup4 requests

      - name: Normalize input (M1 inside M3)
        run: |
          set -euo pipefail
          export PYTHONPATH="$PWD"
          mkdir -p outputs/inputs
          python -m brickovery.cli normalize-input             --config configs/config.v1.yaml             --input inputs/search.xml             --output-dir outputs/inputs

      - name: Resolve snapshot_id (from DB, latest)
        run: |
          set -euo pipefail
          python - <<'PY'
          import os, sqlite3, sys

          db_path = os.path.join("data base", "brickovery.db")
          if not os.path.exists(db_path):
            print(f"ERROR: DB not found: {db_path}")
            print("Action: run M2 refresh-cache first (it populates the DB).")
            sys.exit(1)

          con = sqlite3.connect(db_path)
          con.row_factory = sqlite3.Row

          def cols(table):
            return [r["name"] for r in con.execute(f"PRAGMA table_info('{table}')")]

          def find_col(table, candidates):
            c = set(cols(table))
            for name in candidates:
              if name in c:
                return name
            return None

          def latest_snapshot_from(table):
            try:
              c = cols(table)
            except Exception:
              return None
            snap_col = find_col(table, ["snapshot_id", "run_id", "snapshot"])
            ts_col = find_col(table, ["ingested_ts", "created_ts", "ts", "updated_ts"])
            if not snap_col or not ts_col:
              return None
            q = f"""SELECT {snap_col} AS sid, MAX({ts_col}) AS mx
                    FROM {table}
                    WHERE {snap_col} IS NOT NULL
                    GROUP BY {snap_col}
                    ORDER BY mx DESC
                    LIMIT 1"""
            row = con.execute(q).fetchone()
            if not row:
              return None
            return (row["sid"], row["mx"], table, snap_col, ts_col)

          got = latest_snapshot_from("market_offers") or latest_snapshot_from("market_metrics")
          if not got:
            print("ERROR: Could not resolve snapshot_id from DB tables market_offers/market_metrics.")
            print("Action: run M2 refresh-cache (preferably once with --force after changing search.xml).")
            sys.exit(1)

          sid, mx, table, snap_col, ts_col = got
          print(f"Using snapshot_id={sid} (table={table}, {ts_col} max={mx})")

          # export
          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write(f"SNAPSHOT_ID={sid}\n")
          PY

      - name: Solve (M3)
        run: |
          set -euo pipefail
          export PYTHONPATH="$PWD"

          MODE="${{ github.event.inputs.mode }}"
          if [ "$MODE" = "both" ]; then
            echo "WARN: --mode 'both' is not supported by the CLI; using 'normal'."
            MODE="normal"
          fi

          mkdir -p outputs/solve/checkpoints
          python -m brickovery.cli solve             --config configs/config.v1.yaml             --snapshot-id "${SNAPSHOT_ID}"             --time-budget-minutes "${{ github.event.inputs.time_budget_minutes }}"             --checkpoint-every-seconds "${{ github.event.inputs.checkpoint_every_seconds }}"             --penalty-store "${{ github.event.inputs.penalty_store }}"             --mode "${MODE}"             --output "outputs/solve/seed_solutions.${{ github.run_id }}.json"

      - name: Summary (filtered by shipping_method)
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, os, glob

          focus = os.environ.get("FOCUS", "both").strip().lower()
          paths = sorted(glob.glob("outputs/solve/seed_solutions.*.json"))
          if not paths:
            print("No seed_solutions.*.json found.")
            raise SystemExit(0)
          p = paths[-1]
          with open(p, "r", encoding="utf-8") as f:
            data = json.load(f)

          # expected: data has "scenarios" or is list; print robustly
          scenarios = data.get("scenarios") if isinstance(data, dict) else None
          if scenarios is None and isinstance(data, dict):
            # try common alternative keys
            for k in ("solutions","seed_solutions","results"):
              if k in data:
                scenarios = data[k]
                break
          if scenarios is None:
            scenarios = data if isinstance(data, list) else []

          def keep(name):
            n = str(name).lower()
            if focus == "both":
              return True
            if focus == "normal":
              return n.endswith("_normal") or "_normal" in n
            if focus == "registered":
              return n.endswith("_registered") or "_registered" in n
            return True

          print(f"seed_file={p}")
          print(f"shipping_method_focus={focus}")
          kept = 0
          for s in scenarios:
            if isinstance(s, dict):
              name = s.get("name") or s.get("scenario") or "scenario"
              if keep(name):
                kept += 1
                print(f"- {name} score={s.get('score')} stores={s.get('stores')} missing={s.get('missing')}")
          if kept == 0:
            print("(no scenarios matched the focus; showing raw top-level keys)")
            if isinstance(data, dict):
              print(list(data.keys()))
          PY
        env:
          FOCUS: "${{ github.event.inputs.shipping_method }}"

      - name: Upload solve outputs
        uses: actions/upload-artifact@v4
        with:
          name: brickovery-m3-outputs-${{ github.run_id }}
          path: |
            outputs/solve/**
            outputs/inputs/**
